Jour 1 :
 Apprentissage de l'environnement ROS
  -> Création de package, construction, lancement
  -> Fonctionnement des noeuds, topics (messages) exemple de la tortue
 (un noeud tortue qui est lancé auquel on connecte un autre noeud pour les
  touches tout ça pour le noeud initial /rosouti)
  -> Meme principe que sur le Urbi actuel ce qui faciliterai l'interfaçage entre les deux 
  -> Problématique => Pourquoi cela n'interfacerait pas ? 
  -> Elaboration d'un serveur simple avec message (précision du message dans un format .msg ou .srv (en fonction de qui envoie quoi))
  -> Bien comprendre le principe que c'est une surcouche => le code est ensuite généré en c++ ou python selon le choix.
 
Jour 2 :
 Familiariser avec Urbi

  -> Faire serveur client aussi. DONE => fait de base =>
     urbi --port 54000 ; // On lance un serveur
     on se co ensuite avec telnet, netcat et on envoie directement les infos que l'on veut.

     Fonctionnement avec le C++ => faire directement les classes en .cc et faire une surcouche avec des UObject
       HOWTO
        -> Déclarer dans urbi l'objet => UStart(UMachine)

         class UMachine
  				: public urbi::UObject

					/// Urbi constructor.
					/// \param d the duration of the assembly process.
					///           Must be positive.
					/// \return 0 on success.
						int init(ufloat d);
pas oublier en private

private:
  /// The duration of the assembly process.
  urbi::UVar duration;
  /// The actual machine, wrapped in this UObject.
  Machine* machine;


Dans le .cc

Dans le constructor
// Register the Urbi constructor. This is the only mandatory
// part of the C++ constructor.
UBindFunction(UMachine, init);


UBindFunction(UMachine, assemble);
UBindVar(UMachine, duration);


  -> Bouffer de la doc.
Tentative d'interfaçage ? 
